{% comment %}
==============================================
INTELLIGENT STOREFRONT CLONER - PERFORMANCE MONITOR
==============================================
Advanced performance monitoring and Core Web Vitals tracking system.
Provides real-time performance insights and optimization recommendations.

Features:
- Core Web Vitals monitoring (LCP, FID, CLS)
- Resource loading optimization
- Network performance tracking
- User experience metrics
- Performance budgets and alerts
==============================================
{% endcomment %}

{% liquid
  comment 'Performance Monitor Configuration'
  assign performance_monitoring_enabled = settings.log_performance_metrics | default: false
  assign debug_performance = settings.debug_mode | default: false
  assign performance_budget_lcp = 2500
  assign performance_budget_fid = 100
  assign performance_budget_cls = 0.1
  assign track_analytics = true
  
  comment 'Resource Hints and Preloading'
  assign critical_resources = 'base.css,global.js,theme-architecture-core' | split: ','
  assign preconnect_domains = 'fonts.googleapis.com,fonts.gstatic.com,cdn.shopify.com' | split: ','
  assign prefetch_resources = blank
%}

{% comment %} RESOURCE HINTS AND OPTIMIZATION {% endcomment %}

{% comment %} Preconnect to important domains {% endcomment %}
{% for domain in preconnect_domains %}
  <link rel="preconnect" href="https://{{ domain }}" crossorigin>
{% endfor %}

{% comment %} DNS Prefetch for Shopify CDN {% endcomment %}
<link rel="dns-prefetch" href="//cdn.shopify.com">
<link rel="dns-prefetch" href="//fonts.shopifycdn.com">

{% comment %} Preload critical resources {% endcomment %}
{% if settings.enable_critical_css %}
  <link rel="preload" href="{{ 'base.css' | asset_url }}" as="style" onload="this.onload=null;this.rel='stylesheet'">
{% endif %}

<link rel="preload" href="{{ 'global.js' | asset_url }}" as="script">

{% comment %} PERFORMANCE MONITORING SCRIPT {% endcomment %}
<script>
  // Performance Monitor Core
  window.PerformanceMonitor = {
    config: {
      enabled: {{ performance_monitoring_enabled }},
      debug: {{ debug_performance }},
      budgets: {
        lcp: {{ performance_budget_lcp }},
        fid: {{ performance_budget_fid }},
        cls: {{ performance_budget_cls }}
      },
      trackAnalytics: {{ track_analytics }},
      themeVersion: '1.0.0'
    },

    metrics: {
      lcp: null,
      fid: null,
      cls: null,
      ttfb: null,
      loadTime: null,
      domContentLoaded: null,
      resources: {}
    },

    // Initialize performance monitoring
    init: function() {
      if (!this.config.enabled) return;

      this.setupObservers();
      this.monitorResourceLoading();
      this.trackPageLoad();
      this.setupUserInteractionTracking();
      
      if (this.config.debug) {
        this.enableDebugMode();
      }

      // Report metrics after page load
      window.addEventListener('load', () => {
        setTimeout(() => this.reportMetrics(), 3000);
      });
    },

    // Setup performance observers
    setupObservers: function() {
      if ('PerformanceObserver' in window) {
        // Largest Contentful Paint
        try {
          const lcpObserver = new PerformanceObserver((entryList) => {
            const entries = entryList.getEntries();
            const lastEntry = entries[entries.length - 1];
            this.metrics.lcp = lastEntry.startTime;
            
            if (this.config.debug) {
              console.log('🎯 LCP:', this.metrics.lcp.toFixed(2) + 'ms');
            }

            this.checkBudget('lcp', this.metrics.lcp);
            this.trackMetric('lcp', this.metrics.lcp);
          });
          lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
        } catch (e) {
          console.warn('LCP observer not supported');
        }

        // First Input Delay
        try {
          const fidObserver = new PerformanceObserver((entryList) => {
            const firstInput = entryList.getEntries()[0];
            this.metrics.fid = firstInput.processingStart - firstInput.startTime;
            
            if (this.config.debug) {
              console.log('⚡ FID:', this.metrics.fid.toFixed(2) + 'ms');
            }

            this.checkBudget('fid', this.metrics.fid);
            this.trackMetric('fid', this.metrics.fid);
          });
          fidObserver.observe({ entryTypes: ['first-input'] });
        } catch (e) {
          console.warn('FID observer not supported');
        }

        // Cumulative Layout Shift
        try {
          let clsValue = 0;
          const clsObserver = new PerformanceObserver((entryList) => {
            for (const entry of entryList.getEntries()) {
              if (!entry.hadRecentInput) {
                clsValue += entry.value;
              }
            }
            this.metrics.cls = clsValue;
            
            if (this.config.debug) {
              console.log('📐 CLS:', this.metrics.cls.toFixed(3));
            }

            this.checkBudget('cls', this.metrics.cls);
            this.trackMetric('cls', this.metrics.cls);
          });
          clsObserver.observe({ entryTypes: ['layout-shift'] });
        } catch (e) {
          console.warn('CLS observer not supported');
        }

        // Navigation Timing
        try {
          const navigationObserver = new PerformanceObserver((entryList) => {
            const navigation = entryList.getEntries()[0];
            this.metrics.ttfb = navigation.responseStart - navigation.requestStart;
            this.metrics.loadTime = navigation.loadEventEnd - navigation.navigationStart;
            this.metrics.domContentLoaded = navigation.domContentLoadedEventEnd - navigation.navigationStart;
            
            if (this.config.debug) {
              console.log('🌐 TTFB:', this.metrics.ttfb.toFixed(2) + 'ms');
              console.log('⏱️ Load Time:', this.metrics.loadTime.toFixed(2) + 'ms');
              console.log('🏗️ DOM Ready:', this.metrics.domContentLoaded.toFixed(2) + 'ms');
            }

            this.trackMetric('ttfb', this.metrics.ttfb);
            this.trackMetric('load_time', this.metrics.loadTime);
          });
          navigationObserver.observe({ entryTypes: ['navigation'] });
        } catch (e) {
          console.warn('Navigation timing not supported');
        }

        // Resource Loading
        try {
          const resourceObserver = new PerformanceObserver((entryList) => {
            for (const entry of entryList.getEntries()) {
              this.trackResourceTiming(entry);
            }
          });
          resourceObserver.observe({ entryTypes: ['resource'] });
        } catch (e) {
          console.warn('Resource timing not supported');
        }
      }
    },

    // Monitor resource loading performance
    monitorResourceLoading: function() {
      const criticalResources = {{ critical_resources | json }};
      
      criticalResources.forEach(resource => {
        const startTime = performance.now();
        
        // Track when critical resources finish loading
        if (resource.endsWith('.css')) {
          const link = document.querySelector(`link[href*="${resource}"]`);
          if (link) {
            link.addEventListener('load', () => {
              const loadTime = performance.now() - startTime;
              this.metrics.resources[resource] = loadTime;
              
              if (this.config.debug) {
                console.log(`📄 ${resource} loaded in:`, loadTime.toFixed(2) + 'ms');
              }
            });
          }
        } else if (resource.endsWith('.js')) {
          const script = document.querySelector(`script[src*="${resource}"]`);
          if (script) {
            script.addEventListener('load', () => {
              const loadTime = performance.now() - startTime;
              this.metrics.resources[resource] = loadTime;
              
              if (this.config.debug) {
                console.log(`📜 ${resource} loaded in:`, loadTime.toFixed(2) + 'ms');
              }
            });
          }
        }
      });
    },

    // Track resource timing details
    trackResourceTiming: function(entry) {
      const resource = {
        name: entry.name,
        type: this.getResourceType(entry.name),
        size: entry.transferSize || 0,
        duration: entry.duration,
        startTime: entry.startTime
      };

      // Track slow resources
      if (resource.duration > 1000) { // More than 1 second
        if (this.config.debug) {
          console.warn('🐌 Slow resource:', resource.name, resource.duration.toFixed(2) + 'ms');
        }
        
        this.trackEvent('slow_resource', {
          resource_name: resource.name,
          resource_type: resource.type,
          duration: Math.round(resource.duration)
        });
      }

      // Track large resources
      if (resource.size > 500000) { // More than 500KB
        if (this.config.debug) {
          console.warn('📦 Large resource:', resource.name, (resource.size / 1024).toFixed(2) + 'KB');
        }
        
        this.trackEvent('large_resource', {
          resource_name: resource.name,
          resource_type: resource.type,
          size_kb: Math.round(resource.size / 1024)
        });
      }
    },

    // Get resource type from URL
    getResourceType: function(url) {
      if (url.includes('.css')) return 'stylesheet';
      if (url.includes('.js')) return 'script';
      if (url.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) return 'image';
      if (url.match(/\.(woff|woff2|ttf|otf)$/i)) return 'font';
      if (url.includes('.json')) return 'xhr';
      return 'other';
    },

    // Track page load performance
    trackPageLoad: function() {
      window.addEventListener('load', () => {
        const navigation = performance.getEntriesByType('navigation')[0];
        
        if (navigation) {
          const metrics = {
            dns_lookup: navigation.domainLookupEnd - navigation.domainLookupStart,
            tcp_connect: navigation.connectEnd - navigation.connectStart,
            tls_handshake: navigation.secureConnectionStart > 0 ? 
              navigation.connectEnd - navigation.secureConnectionStart : 0,
            server_response: navigation.responseEnd - navigation.responseStart,
            dom_processing: navigation.domContentLoadedEventStart - navigation.responseEnd,
            resource_loading: navigation.loadEventStart - navigation.domContentLoadedEventStart
          };

          if (this.config.debug) {
            console.table(metrics);
          }

          Object.entries(metrics).forEach(([key, value]) => {
            this.trackMetric(key, value);
          });
        }
      });
    },

    // Setup user interaction tracking
    setupUserInteractionTracking: function() {
      let interactionCount = 0;
      const startTime = performance.now();

      ['click', 'keydown', 'scroll'].forEach(eventType => {
        document.addEventListener(eventType, () => {
          interactionCount++;
          
          // Track time to first interaction
          if (interactionCount === 1) {
            const timeToFirstInteraction = performance.now() - startTime;
            this.trackMetric('time_to_first_interaction', timeToFirstInteraction);
            
            if (this.config.debug) {
              console.log('👆 Time to first interaction:', timeToFirstInteraction.toFixed(2) + 'ms');
            }
          }
        }, { once: eventType === 'click' || eventType === 'keydown' });
      });
    },

    // Check performance budgets
    checkBudget: function(metric, value) {
      const budget = this.config.budgets[metric];
      if (!budget) return;

      const exceeded = value > budget;
      const threshold = exceeded ? 'exceeded' : 'within';
      
      if (exceeded && this.config.debug) {
        console.warn(`⚠️ Performance budget ${metric.toUpperCase()} exceeded:`, 
          value.toFixed(2), 'vs budget:', budget);
      }

      this.trackEvent('performance_budget_check', {
        metric: metric,
        value: Math.round(value),
        budget: budget,
        status: threshold
      });
    },

    // Track individual metrics
    trackMetric: function(name, value) {
      if (!this.config.trackAnalytics) return;

      // Send to Google Analytics
      if (typeof gtag !== 'undefined') {
        gtag('event', 'performance_metric', {
          event_category: 'Performance',
          event_label: name,
          value: Math.round(value),
          custom_map: { metric_1: name }
        });
      }

      // Send to Shopify Analytics
      if (typeof analytics !== 'undefined' && analytics.track) {
        analytics.track('Performance Metric', {
          metric: name,
          value: value,
          theme: 'intelligent-storefront-cloner',
          timestamp: Date.now()
        });
      }
    },

    // Track events
    trackEvent: function(eventName, properties = {}) {
      if (!this.config.trackAnalytics) return;

      if (typeof gtag !== 'undefined') {
        gtag('event', eventName, {
          event_category: 'Performance',
          ...properties
        });
      }
    },

    // Generate performance report
    generateReport: function() {
      const report = {
        timestamp: new Date().toISOString(),
        theme: 'intelligent-storefront-cloner',
        version: this.config.themeVersion,
        url: window.location.href,
        userAgent: navigator.userAgent,
        connection: this.getConnectionInfo(),
        metrics: this.metrics,
        budgets: this.config.budgets,
        recommendations: this.generateRecommendations()
      };

      if (this.config.debug) {
        console.group('📊 Performance Report');
        console.table(this.metrics);
        console.log('💡 Recommendations:', report.recommendations);
        console.groupEnd();
      }

      return report;
    },

    // Get connection information
    getConnectionInfo: function() {
      if ('connection' in navigator) {
        return {
          effectiveType: navigator.connection.effectiveType,
          downlink: navigator.connection.downlink,
          rtt: navigator.connection.rtt,
          saveData: navigator.connection.saveData
        };
      }
      return null;
    },

    // Generate performance recommendations
    generateRecommendations: function() {
      const recommendations = [];

      if (this.metrics.lcp > this.config.budgets.lcp) {
        recommendations.push('Consider optimizing Largest Contentful Paint by preloading critical images');
      }

      if (this.metrics.fid > this.config.budgets.fid) {
        recommendations.push('Reduce First Input Delay by minimizing JavaScript execution time');
      }

      if (this.metrics.cls > this.config.budgets.cls) {
        recommendations.push('Improve Cumulative Layout Shift by setting image dimensions');
      }

      if (this.metrics.ttfb > 800) {
        recommendations.push('Optimize Time to First Byte through server improvements');
      }

      return recommendations;
    },

    // Report all metrics
    reportMetrics: function() {
      const report = this.generateReport();
      
      // Send to analytics
      this.trackEvent('performance_report', {
        lcp: Math.round(report.metrics.lcp || 0),
        fid: Math.round(report.metrics.fid || 0),
        cls: Math.round((report.metrics.cls || 0) * 1000) / 1000,
        ttfb: Math.round(report.metrics.ttfb || 0),
        load_time: Math.round(report.metrics.loadTime || 0)
      });

      // Store report for debugging
      if (this.config.debug) {
        window.performanceReport = report;
      }

      return report;
    },

    // Enable debug mode with visual indicators
    enableDebugMode: function() {
      // Create debug panel
      const debugPanel = document.createElement('div');
      debugPanel.id = 'performance-debug-panel';
      debugPanel.innerHTML = `
        <div style="position: fixed; top: 60px; right: 10px; background: #1f2937; color: #f3f4f6; padding: 1rem; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 9999; min-width: 250px; box-shadow: 0 10px 25px rgba(0,0,0,0.2);">
          <strong style="color: #10b981;">⚡ Performance Monitor</strong><br><br>
          <div id="lcp-metric">🎯 LCP: <span>--</span>ms</div>
          <div id="fid-metric">⚡ FID: <span>--</span>ms</div>
          <div id="cls-metric">📐 CLS: <span>--</span></div>
          <div id="ttfb-metric">🌐 TTFB: <span>--</span>ms</div><br>
          <div style="font-size: 10px; opacity: 0.7;">Theme: ISC v1.0.0</div>
        </div>
      `;
      document.body.appendChild(debugPanel);

      // Update metrics in real-time
      const updateDebugPanel = () => {
        const lcp = document.querySelector('#lcp-metric span');
        const fid = document.querySelector('#fid-metric span');
        const cls = document.querySelector('#cls-metric span');
        const ttfb = document.querySelector('#ttfb-metric span');

        if (lcp && this.metrics.lcp) lcp.textContent = this.metrics.lcp.toFixed(0);
        if (fid && this.metrics.fid) fid.textContent = this.metrics.fid.toFixed(0);
        if (cls && this.metrics.cls) cls.textContent = this.metrics.cls.toFixed(3);
        if (ttfb && this.metrics.ttfb) ttfb.textContent = this.metrics.ttfb.toFixed(0);
      };

      setInterval(updateDebugPanel, 1000);

      // Add performance timing marks
      if (performance.mark) {
        performance.mark('performance-monitor-initialized');
      }
    }
  };

  // Auto-initialize if enabled
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      PerformanceMonitor.init();
    });
  } else {
    PerformanceMonitor.init();
  }

  {% if debug_performance %}
    console.log('📊 Performance Monitor Initialized');
    console.log('⚙️ Config:', PerformanceMonitor.config);
  {% endif %}
</script>

{% comment %} RESOURCE OPTIMIZATION {% endcomment %}

{% comment %} Service Worker for advanced caching (optional) {% endcomment %}
{% if settings.enable_service_worker %}
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js')
        .then(registration => {
          console.log('🔧 Service Worker registered:', registration);
        })
        .catch(error => {
          console.log('❌ Service Worker registration failed:', error);
        });
    }
  </script>
{% endif %}

{% comment %} Critical Resource Monitoring {% endcomment %}
<script>
  // Monitor critical resource loading
  window.addEventListener('load', function() {
    const criticalResources = [
      '{{ "base.css" | asset_url }}',
      '{{ "global.js" | asset_url }}',
      '{{ "theme-architecture-core" | asset_url }}'
    ];

    criticalResources.forEach(resource => {
      const entries = performance.getEntriesByName(resource);
      if (entries.length > 0) {
        const entry = entries[0];
        console.log(`📦 ${resource.split('/').pop()}: ${entry.duration.toFixed(2)}ms`);
      }
    });
  });
</script>

{% comment %} ERROR TRACKING {% endcomment %}
<script>
  window.addEventListener('error', function(event) {
    if (PerformanceMonitor.config.trackAnalytics) {
      PerformanceMonitor.trackEvent('javascript_error', {
        message: event.message,
        filename: event.filename,
        line: event.lineno,
        column: event.colno
      });
    }
    
    if (PerformanceMonitor.config.debug) {
      console.error('❌ JavaScript Error:', event);
    }
  });

  window.addEventListener('unhandledrejection', function(event) {
    if (PerformanceMonitor.config.trackAnalytics) {
      PerformanceMonitor.trackEvent('promise_rejection', {
        reason: event.reason?.toString() || 'Unknown'
      });
    }
    
    if (PerformanceMonitor.config.debug) {
      console.error('❌ Unhandled Promise Rejection:', event);
    }
  });
</script>

<style>
  /* Performance optimization styles */
  .perf-critical {
    content-visibility: auto;
    contain-intrinsic-size: 0 200px;
  }

  .perf-lazy {
    loading: lazy;
    decoding: async;
  }

  /* Reduce layout shifts */
  img:not([width]):not([height]) {
    aspect-ratio: 16 / 9;
  }

  /* Optimize animations for performance */
  @media (prefers-reduced-motion: no-preference) {
    .perf-animate {
      will-change: transform, opacity;
      transform: translate3d(0, 0, 0);
      backface-visibility: hidden;
    }
  }

  {% if debug_performance %}
    /* Debug mode visual indicators */
    .debug-performance * {
      outline: 1px solid rgba(255, 0, 0, 0.1) !important;
    }

    .debug-performance .slow-element {
      background-color: rgba(255, 255, 0, 0.2) !important;
    }
  {% endif %}
</style>